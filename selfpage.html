<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>CD Collection</title>
        <link rel="stylesheet" href="selfpage.css?cb=50" />
</head>
<body>
    <div class="top-actions" aria-label="External links">
        <!--<p><a href="https://www.discogs.com/user/bustasomerhymes/collection" style="color: #FFD400;">link</a></p>-->

        <button id="ceelo-open-btn" class="top-action-btn" type="button" aria-label="Open Cee-lo game" title="Open Cee-lo game">
            <img src="six.jpg" alt="Six">
        </button>
    </div>
    
    <div class="container">
    <!-- <div class="banner">
            <img src="banner2.png" alt="Banner">
        </div> -->

        <div class="header">
            <h2>
                <span id="release-header">
                    <span class="release-header-controls">
                        Release
                        <button id="sort-artist-btn" class="sort-button">▼</button>
                        <button id="release-search-toggle" class="search-toggle-button" aria-label="Search albums or artists" title="Search albums or artists"></button>
                        <span id="release-search-panel" class="release-search-panel" aria-hidden="true">
                            <input id="album-search-input" class="album-search-input" type="text" placeholder="Search albums or artists..." aria-label="Search albums or artists">
                        </span>
                    </span>
                </span>
                <span>Catalog</span>
                <span id="identification-header">Identification <button id="sort-year-btn" class="sort-button">▼</button></span>
                <span id="acquisition-header">Acquisition Details <button id="sort-date-btn" class="sort-button">▼</button><button id="sort-price-btn" class="sort-button" aria-label="Sort by price"></button></span>
                <span id="rating-header" style="cursor: pointer;" title="Click to see rating meanings">Personal Rating <button id="sort-rating-btn" class="sort-button">▼</button></span>
            </h2>
        </div>

        <div class="table-wrapper">
            <table class="cd-table">
                <colgroup>
                    <col style="width:20%">
                    <col style="width:26%">
                    <col style="width:26%">
                    <col style="width:18%">
                    <col style="width:10%">
                </colgroup>
                <tbody id="cdTableBody">
                    <!-- Rows will be generated by JavaScript -->
                </tbody>
            </table>
        </div>
    </div>

    <!-- Rating Info Popup -->
    <div id="ratingPopup" class="rating-popup">
        <div class="rating-popup-content">
            <span class="rating-close">&times;</span>
            <h3>Personal Rating Scale</h3>
            <div class="rating-scale">
                <div class="rating-item">
                    <span class="rating-number">7</span>
                    <span class="rating-label">Favourite</span>
                </div>
                <div class="rating-item">
                    <span class="rating-number">6</span>
                    <span class="rating-label">Amazing</span>
                </div>
                <div class="rating-item">
                    <span class="rating-number">5</span>
                    <span class="rating-label">Very Good</span>
                </div>
                <div class="rating-item">
                    <span class="rating-number">4</span>
                    <span class="rating-label">Good</span>
                </div>
                <div class="rating-item">
                    <span class="rating-number">3</span>
                    <span class="rating-label">Decent</span>
                </div>
                <div class="rating-item">
                    <span class="rating-number">2</span>
                    <span class="rating-label">Subpar</span>
                </div>
                <div class="rating-item">
                    <span class="rating-number">1</span>
                    <span class="rating-label">Bad</span>
                </div>
                <div class="rating-item">
                    <span class="rating-number">0</span>
                    <span class="rating-label">Awful</span>
                </div>
            </div>
        </div>
    </div>

    <div id="ceeloPopup" class="ceelo-popup" aria-hidden="true">
        <div class="ceelo-popup-content">
            <button id="ceelo-close-btn" class="ceelo-close" type="button" aria-label="Close Cee-lo game">X</button>
            <div class="ceelo-layout">
                <div class="ceelo-art">
                    <img src="ceelo.png" alt="Cee-lo">
                </div>
                <div class="ceelo-game">
                    <div class="ceelo-bankroll-row">
                        <span class="ceelo-label">Bankroll:</span>
                        <span id="ceelo-balance" class="ceelo-value">$1000</span>
                    </div>

                    <div class="ceelo-bet-row">
                        <label for="ceelo-bet" class="ceelo-label">Bet:</label>
                        <input id="ceelo-bet" class="ceelo-bet-input" type="number" min="50" step="50" value="50">
                        <button id="ceelo-start-round" class="ceelo-btn" type="button">Place Bet</button>
                    </div>

                    <div class="ceelo-rolls">
                        <div class="ceelo-side ceelo-banker-side">
                            <p class="ceelo-side-title">Banker</p>
                            <div id="ceelo-banker-dice" class="ceelo-dice-row">
                                <img src="one.png" alt="Banker die 1">
                                <img src="one.png" alt="Banker die 2">
                                <img src="one.png" alt="Banker die 3">
                            </div>
                            <p id="ceelo-banker-result" class="ceelo-result">Waiting...</p>
                            <button id="ceelo-roll-banker" class="ceelo-btn" type="button" disabled>Roll Banker</button>
                        </div>
                        <div class="ceelo-side">
                            <p class="ceelo-side-title">Player</p>
                            <div id="ceelo-player-dice" class="ceelo-dice-row">
                                <img src="one.png" alt="Player die 1">
                                <img src="one.png" alt="Player die 2">
                                <img src="one.png" alt="Player die 3">
                            </div>
                            <p id="ceelo-player-result" class="ceelo-result">Waiting...</p>
                            <button id="ceelo-roll-player" class="ceelo-btn" type="button" disabled>Roll Player</button>
                        </div>
                    </div>

                    <div id="ceelo-message-log" class="ceelo-message-log" aria-live="polite">
                        <div class="ceelo-message-item">Set your bet to start the round.</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <audio id="ceelo-bg-music" loop>
        <source src="mrclean.mp3" type="audio/mpeg">
    </audio>

    <audio id="dice-shake-sfx">
        <source src="diceshake.mp3" type="audio/mpeg">
    </audio>

    <script>
        // Rating Popup functionality
        const ratingHeader = document.getElementById('rating-header');
        const ratingPopup = document.getElementById('ratingPopup');
        const ratingClose = document.querySelector('.rating-close');

        ratingHeader.addEventListener('click', function(e) {
            // Don't trigger if clicking the sort button
            if (e.target.id === 'sort-rating-btn' || e.target.closest('button')) {
                return;
            }
            ratingPopup.classList.add('show');
        });

        ratingClose.addEventListener('click', function() {
            ratingPopup.classList.remove('show');
        });

        window.addEventListener('click', function(e) {
            if (e.target === ratingPopup) {
                ratingPopup.classList.remove('show');
            }
        });

        const ceeloOpenBtn = document.getElementById('ceelo-open-btn');
        const ceeloPopup = document.getElementById('ceeloPopup');
        const ceeloCloseBtn = document.getElementById('ceelo-close-btn');
        const ceeloBalance = document.getElementById('ceelo-balance');
        const ceeloBetInput = document.getElementById('ceelo-bet');
        const ceeloStartRoundBtn = document.getElementById('ceelo-start-round');
        const ceeloRollBankerBtn = document.getElementById('ceelo-roll-banker');
        const ceeloRollPlayerBtn = document.getElementById('ceelo-roll-player');
        const ceeloBankerDice = document.getElementById('ceelo-banker-dice');
        const ceeloPlayerDice = document.getElementById('ceelo-player-dice');
        const ceeloBankerResult = document.getElementById('ceelo-banker-result');
        const ceeloPlayerResult = document.getElementById('ceelo-player-result');
        const ceeloMessageLog = document.getElementById('ceelo-message-log');
        const ceeloBgMusic = document.getElementById('ceelo-bg-music');
        const diceShakeSfx = document.getElementById('dice-shake-sfx');

        if (ceeloBgMusic) {
            ceeloBgMusic.volume = 0.15;
        }

        const ceeloDiceFaceByNumber = {
            1: 'one.png',
            2: 'two.png',
            3: 'three.png',
            4: 'four.jpg',
            5: 'five.png',
            6: 'six.jpg'
        };

        const ceeloState = {
            balance: 1000,
            currentBet: 0,
            bankerResult: null,
            playerResult: null,
            phase: 'idle',
            hasCompletedRound: false,
            lastRoundSummary: '',
            allInConfirmationPending: false
        };

        function ceeloFormatMoney(value) {
            return '$' + Math.floor(value);
        }

        function ceeloUpdateBalanceText() {
            ceeloBalance.textContent = ceeloFormatMoney(ceeloState.balance);
        }

        function ceeloSetDice(diceRowEl, diceValues, sideLabel) {
            const diceImages = diceRowEl.querySelectorAll('img');
            diceValues.forEach((value, index) => {
                if (!diceImages[index]) return;
                diceImages[index].src = ceeloDiceFaceByNumber[value];
                diceImages[index].alt = sideLabel + ' die ' + (index + 1) + ': ' + value;
            });
        }

        function ceeloRollThreeDice() {
            return [
                Math.floor(Math.random() * 6) + 1,
                Math.floor(Math.random() * 6) + 1,
                Math.floor(Math.random() * 6) + 1
            ];
        }

        function ceeloSleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function ceeloEvaluateRoll(diceValues) {
            const sorted = [...diceValues].sort((a, b) => a - b);

            if (sorted[0] === 1 && sorted[1] === 2 && sorted[2] === 3) {
                return { kind: 'auto-loss', text: '1, 2, 3 Auto Loss' };
            }

            if (sorted[0] === 4 && sorted[1] === 5 && sorted[2] === 6) {
                return { kind: 'auto-win', text: '4, 5, 6 Auto Win' };
            }

            if (sorted[0] === sorted[1] && sorted[1] === sorted[2]) {
                return { kind: 'trips', value: sorted[0], text: 'Trips ' + sorted[0] + ', ' + sorted[1] + ', ' + sorted[2] };
            }

            if (sorted[0] === sorted[1]) {
                return { kind: 'point', value: sorted[2], text: 'Point ' + sorted[2] + ' (double ' + sorted[0] + ')' };
            }

            if (sorted[1] === sorted[2]) {
                return { kind: 'point', value: sorted[0], text: 'Point ' + sorted[0] + ' (double ' + sorted[1] + ')' };
            }

            return { kind: 'bust', text: 'No Point' };
        }

        function ceeloRank(result) {
            if (result.kind === 'auto-win') return 5;
            if (result.kind === 'trips') return 4;
            if (result.kind === 'point') return 3;
            if (result.kind === 'bust') return 2;
            return 1;
        }

        function ceeloCompareRounds(bankerResult, playerResult) {
            const bankerRank = ceeloRank(bankerResult);
            const playerRank = ceeloRank(playerResult);

            if (playerRank > bankerRank) return 'player';
            if (bankerRank > playerRank) return 'banker';

            if (playerResult.kind === 'trips') {
                if (playerResult.value > bankerResult.value) return 'player';
                if (bankerResult.value > playerResult.value) return 'banker';
                return 'push';
            }

            if (playerResult.kind === 'point') {
                if (playerResult.value > bankerResult.value) return 'player';
                if (bankerResult.value > playerResult.value) return 'banker';
                return 'push';
            }

            return 'push';
        }

        function ceeloSetMessage(text) {
            if (!ceeloMessageLog) return;
            const messageItem = document.createElement('div');
            messageItem.className = 'ceelo-message-item';
            messageItem.textContent = text;
            ceeloMessageLog.appendChild(messageItem);
            ceeloMessageLog.scrollTop = ceeloMessageLog.scrollHeight;
        }

        function ceeloResetMessageLog() {
            if (!ceeloMessageLog) return;
            ceeloMessageLog.innerHTML = '';
            ceeloSetMessage('Set your bet to start the round.');
        }

        function ceeloResetMessageLogForRound() {
            if (!ceeloMessageLog) return;
            ceeloMessageLog.innerHTML = '';

            if (ceeloState.hasCompletedRound && ceeloState.lastRoundSummary) {
                ceeloSetMessage('Last round: ' + ceeloState.lastRoundSummary);
            }
        }

        function ceeloResetForNewBet() {
            ceeloState.bankerResult = null;
            ceeloState.playerResult = null;
            ceeloState.phase = 'bet-ready';
            ceeloState.allInConfirmationPending = false;
            ceeloBankerResult.textContent = 'Waiting...';
            ceeloPlayerResult.textContent = 'Waiting...';
            if (ceeloRollBankerBtn) ceeloRollBankerBtn.disabled = true;
            ceeloRollPlayerBtn.disabled = true;
        }

        function ceeloOpenPopup() {
            ceeloPopup.classList.add('show');
            ceeloPopup.setAttribute('aria-hidden', 'false');
            if (ceeloBgMusic) {
                ceeloBgMusic.currentTime = 0;
                ceeloBgMusic.play().catch(() => {});
            }
            if (ceeloMessageLog && !ceeloMessageLog.querySelector('.ceelo-message-item')) {
                ceeloResetMessageLog();
            }
            ceeloBetInput.focus();
        }

        function ceeloClosePopup() {
            ceeloPopup.classList.remove('show');
            ceeloPopup.setAttribute('aria-hidden', 'true');
            if (ceeloBgMusic) {
                ceeloBgMusic.pause();
                ceeloBgMusic.currentTime = 0;
            }
        }

        async function ceeloAnimateSingleRoll(diceRowEl, sideLabel) {
            diceRowEl.classList.add('is-rolling');

            if (diceShakeSfx) {
                diceShakeSfx.currentTime = 0;
                diceShakeSfx.play().catch(() => {});
            }

            for (let frame = 0; frame < 7; frame++) {
                ceeloSetDice(diceRowEl, ceeloRollThreeDice(), sideLabel);
                await ceeloSleep(80);
            }

            const finalDice = ceeloRollThreeDice();
            ceeloSetDice(diceRowEl, finalDice, sideLabel);
            diceRowEl.classList.remove('is-rolling');
            return { diceValues: finalDice, result: ceeloEvaluateRoll(finalDice) };
        }

        async function ceeloResolveQualifiedRoll(diceRowEl, resultEl, sideLabel, autoRerollOnBust) {
            let rollOutcome = await ceeloAnimateSingleRoll(diceRowEl, sideLabel);
            resultEl.textContent = rollOutcome.result.text;

            while (autoRerollOnBust && rollOutcome.result.kind === 'bust') {
                await ceeloSleep(1000);
                rollOutcome = await ceeloAnimateSingleRoll(diceRowEl, sideLabel);
                resultEl.textContent = rollOutcome.result.text;
            }

            return rollOutcome.result;
        }

        function ceeloFinishRound(winner) {
            if (winner === 'player') {
                ceeloState.balance += ceeloState.currentBet;
                ceeloState.lastRoundSummary = 'Player wins ' + ceeloFormatMoney(ceeloState.currentBet) + '. You may place another bet.';
                ceeloSetMessage(ceeloState.lastRoundSummary);
            } else if (winner === 'banker') {
                ceeloState.balance -= ceeloState.currentBet;
                ceeloState.lastRoundSummary = 'Banker wins ' + ceeloFormatMoney(ceeloState.currentBet) + '. You may place another bet.';
                ceeloSetMessage(ceeloState.lastRoundSummary);
            } else {
                ceeloState.lastRoundSummary = 'Push. No mula moves this round. You may place another bet.';
                ceeloSetMessage(ceeloState.lastRoundSummary);
            }

            if (ceeloState.balance < 0) {
                ceeloState.balance = 0;
            }

            ceeloUpdateBalanceText();
            ceeloState.phase = 'round-over';
            ceeloState.hasCompletedRound = true;
            ceeloRollPlayerBtn.disabled = true;
        }

        async function ceeloRollBankerAuto() {
            if (ceeloState.phase !== 'bet-ready') return;
            ceeloState.phase = 'banker-rolling';
            ceeloSetMessage('Banker rolling...');
            ceeloState.bankerResult = await ceeloResolveQualifiedRoll(ceeloBankerDice, ceeloBankerResult, 'Banker', true);

            if (ceeloState.bankerResult.kind === 'auto-win') {
                ceeloSetMessage('Banker hit 4, 5, 6. INSTA win.');
                ceeloFinishRound('banker');
                return;
            }

            if (ceeloState.bankerResult.kind === 'auto-loss') {
                ceeloSetMessage('Banker hit 1, 2, 3. INSTA loss.');
                ceeloFinishRound('player');
                return;
            }

            ceeloState.phase = 'player-turn';
            ceeloRollPlayerBtn.disabled = false;
            ceeloSetMessage('Banker set: ' + ceeloState.bankerResult.text + '. Player\'s turn.');
        }

        function ceeloNormalizeBetInput(rawValue) {
            if (Number.isNaN(rawValue) || rawValue <= 0) return 0;
            return Math.floor(rawValue / 50) * 50;
        }

        async function ceeloPlaceBet() {
            const betValue = parseInt(ceeloBetInput.value, 10);
            const normalizedBet = ceeloNormalizeBetInput(betValue);

            if (ceeloState.balance <= 0) {
                ceeloSetMessage('You ran out of mula.. what now??');
                return;
            }

            if (normalizedBet < 50) {
                ceeloSetMessage('Bet must be at least $50.');
                return;
            }

            if (normalizedBet > ceeloState.balance) {
                ceeloSetMessage('Not enough bankroll for that bet.');
                return;
            }

            if (normalizedBet === ceeloState.balance && !ceeloState.allInConfirmationPending) {
                ceeloSetMessage('Are you sure you want to bet all of your bank funds? Press \'Place Bet\' again to confirm.');
                ceeloState.allInConfirmationPending = true;
                return;
            }

            ceeloState.currentBet = normalizedBet;
            ceeloBetInput.value = String(normalizedBet);
            ceeloResetMessageLogForRound();
            ceeloResetForNewBet();
            ceeloSetMessage('Bet locked at ' + ceeloFormatMoney(normalizedBet));
            await ceeloSleep(1000);
            await ceeloRollBankerAuto();
        }

        async function ceeloRollPlayer() {
            if (ceeloState.phase !== 'player-turn') return;
            ceeloState.phase = 'player-rolling';
            ceeloRollPlayerBtn.disabled = true;
            ceeloSetMessage('Player rolling...');
            const playerRollOutcome = await ceeloResolveQualifiedRoll(ceeloPlayerDice, ceeloPlayerResult, 'Player', false);

            if (playerRollOutcome.kind === 'bust') {
                ceeloState.phase = 'player-turn';
                ceeloRollPlayerBtn.disabled = false;
                ceeloSetMessage('Bust. Roll again.');
                return;
            }

            ceeloState.playerResult = playerRollOutcome;

            if (ceeloState.playerResult.kind === 'auto-win') {
                ceeloSetMessage('Player hit 4, 5, 6. INSTA win.');
                ceeloFinishRound('player');
                return;
            }

            if (ceeloState.playerResult.kind === 'auto-loss') {
                ceeloSetMessage('Player hit 1, 2, 3. INSTA loss.');
                ceeloFinishRound('banker');
                return;
            }

            const winner = ceeloCompareRounds(ceeloState.bankerResult, ceeloState.playerResult);
            ceeloFinishRound(winner);
        }

        if (ceeloOpenBtn && ceeloPopup && ceeloCloseBtn) {
            ceeloOpenBtn.addEventListener('click', ceeloOpenPopup);
            ceeloCloseBtn.addEventListener('click', ceeloClosePopup);

            window.addEventListener('click', function(e) {
                if (e.target === ceeloPopup) {
                    ceeloClosePopup();
                }
            });

            ceeloStartRoundBtn.addEventListener('click', ceeloPlaceBet);
            ceeloRollPlayerBtn.addEventListener('click', ceeloRollPlayer);

            ceeloBetInput.addEventListener('keydown', function(event) {
                if (event.key === 'Enter') {
                    ceeloPlaceBet();
                }
            });

            ceeloUpdateBalanceText();
        }

        // Sort state
        let sortAscendingArtist = true;
        let sortAscendingYear = false;
        let sortAscendingDate = true;
        let sortAscendingPrice = true;
        let sortAscendingRating = true;
        let cachedData = null;

        // Function to generate stars from rating (1-7) using PNG images
        function generateStars(rating) {
            if (!rating) return '';
            
            // Check if rating is "Pending" - just return empty string
            if (String(rating).toLowerCase().trim() === 'pending') {
                return '';
            }
            
            const ratingNum = parseFloat(rating);
            const fullStars = Math.floor(ratingNum);
            const hasHalf = ratingNum % 1 !== 0;
            const emptyStars = 7 - fullStars - (hasHalf ? 1 : 0);
            
            let html = '';
            
            // Full stars
            for (let i = 0; i < fullStars; i++) {
                html += '<img src="Full_Star.png" alt="full star" class="star-icon">';
            }
            
            // Half star if exists
            if (hasHalf) {
                html += '<img src="Half_Star.png" alt="half star" class="star-icon">';
            }
            
            // Empty stars
            for (let i = 0; i < emptyStars; i++) {
                html += '<img src="Empty_Star.png" alt="empty star" class="star-icon">';
            }
            
            return html;
        }

        // Format price to always include € when applicable, using comma as decimal separator
        function formatPrice(price) {
            if (price === null || price === undefined) return '-';
            if (price === '-' || price === '') return '';
            // If it's already a string containing € return trimmed value
            if (typeof price === 'string') {
                const trimmed = price.trim();
                if (trimmed.endsWith('€')) return trimmed;
                const num = Number(trimmed);
                if (!isNaN(num)) {
                    return num.toLocaleString('de-DE', {minimumFractionDigits: 2, maximumFractionDigits: 2}) + '€';
                }
                return trimmed + '€';
            }
            if (typeof price === 'number') {
                return price.toLocaleString('de-DE', {minimumFractionDigits: 2, maximumFractionDigits: 2}) + '€';
            }
            return String(price) + '€';
        }

        // Render a labeled field only if value exists and is not '-'
        function renderField(label, value, className, useStrong = true) {
            if (value === null || value === undefined) return '';
            if (String(value).trim() === '' || String(value).trim() === '-') return '';
            const content = String(value).trim();
            if (label) {
                return `<div class="field ${className}">${useStrong ? `<strong>${label}</strong> ` : ''}${content}</div>`;
            }
            return `<div class="field ${className}">${content}</div>`;
        }

        function getAlbumSearchQuery() {
            const searchInput = document.getElementById('album-search-input');
            return searchInput ? searchInput.value.trim().toLowerCase() : '';
        }

        function getFilteredCds() {
            if (!cachedData || !Array.isArray(cachedData.cds)) return [];
            const query = getAlbumSearchQuery();
            if (!query) return cachedData.cds;

            return cachedData.cds.filter(cd => {
                const albumTitle = (cd.albumTitle || '').toString().toLowerCase();
                const artistName = (cd.artistName || '').toString().toLowerCase();
                return albumTitle.includes(query) || artistName.includes(query);
            });
        }

        function applyAlbumSearch() {
            renderTable(getFilteredCds());
        }

        // Function to render table rows
        function renderTable(cds) {
            const tableBody = document.getElementById('cdTableBody');
            tableBody.innerHTML = ''; // Clear existing rows
            
            cds.forEach(cd => {
                const row = document.createElement('tr');
                row.className = 'cd-row';

                row.innerHTML = `
                    <td class="col-release">
                        <div class="release-container">
                            <img class="album-cover" src="${cd.imageUrl || 'placeholder.png'}" alt="${cd.albumTitle}">
                            <div class="release-text">
                                <div class="field album-title">${cd.albumTitle}</div>
                                <div class="field artist-name">${cd.artistName}</div>
                            </div>
                        </div>
                    </td>
                    <td class="col-catalog">
                        ${renderField('Label:', cd.label, 'label')}
                        ${renderField('Catalog Nº:', cd.catalogNumber, 'catalog-number')}
                    </td>
                    <td class="col-identification">
                        ${renderField('Matrix:', cd.matrix, 'matrix')}
                        ${renderField("SID's:", cd.sids, 'sids')}
                        ${ (cd.year && cd.region && String(cd.year).trim() !== '-' && String(cd.region).trim() !== '-') ? `<div class="field year-region">${cd.year} - ${cd.region}</div>` : (cd.year && String(cd.year).trim() !== '-' ? `<div class="field year-region">${cd.year}</div>` : (cd.region && String(cd.region).trim() !== '-' ? `<div class="field year-region">${cd.region}</div>` : '')) }
                    </td>
                    <td class="col-acquisition">
                        ${renderField('', cd.dateAcquisition, 'date', false)}
                        ${ cd.price && String(cd.price).trim() !== '-' ? `<div class="field price">${formatPrice(cd.price)}</div>` : '' }
                    </td>
                    <td class="col-rating">
                        <div class="field rating">${generateStars(cd.rating)}</div>
                    </td>
                `;

                tableBody.appendChild(row);
            });
        }

        // Helper function to strip leading articles for sorting
        function stripArticle(name) {
            return name.replace(/^the\s+/i, '');
        }

        // Sort by artist name
        function sortByArtist() {
            if (!cachedData) return;

            // Toggle sort direction FIRST
            sortAscendingArtist = !sortAscendingArtist;

            cachedData.cds.sort((a, b) => {
                const nameA = stripArticle((a.artistName || '').toLowerCase());
                const nameB = stripArticle((b.artistName || '').toLowerCase());
                
                if (sortAscendingArtist) {
                    return nameA.localeCompare(nameB);
                } else {
                    return nameB.localeCompare(nameA);
                }
            });

            // Update button appearance
            const sortBtn = document.getElementById('sort-artist-btn');
            if (sortAscendingArtist) {
                sortBtn.classList.remove('descending');
                sortBtn.classList.add('ascending');
            } else {
                sortBtn.classList.add('descending');
                sortBtn.classList.remove('ascending');
            }

            // Re-render table (respect active search filter)
            applyAlbumSearch();
        }

        // Sort by year
        function sortByYear() {
            if (!cachedData) return;

            // Toggle sort direction FIRST
            sortAscendingYear = !sortAscendingYear;

            cachedData.cds.sort((a, b) => {
                // Extract year number from strings like "Repress(ca. 2012)" or "2012"
                const yearMatchA = (a.year || '').match(/\d{4}/);
                const yearMatchB = (b.year || '').match(/\d{4}/);
                const yearA = yearMatchA ? parseInt(yearMatchA[0]) : 0;
                const yearB = yearMatchB ? parseInt(yearMatchB[0]) : 0;
                
                // Put items without year at the bottom
                if (yearA === 0 && yearB === 0) return 0;
                if (yearA === 0) return 1;
                if (yearB === 0) return -1;
                
                if (sortAscendingYear) {
                    return yearA - yearB;
                } else {
                    return yearB - yearA;
                }
            });

            // Update button appearance
            const sortBtn = document.getElementById('sort-year-btn');
            if (sortAscendingYear) {
                sortBtn.classList.add('descending');
                sortBtn.classList.remove('ascending');
            } else {
                sortBtn.classList.remove('descending');
                sortBtn.classList.add('ascending');
            }

            // Re-render table (respect active search filter)
            applyAlbumSearch();
        }

        // Sort by date
        function sortByDate() {
            if (!cachedData) return;

            // Toggle sort direction FIRST
            sortAscendingDate = !sortAscendingDate;

            // Helper function to parse DD/MM/YYYY format
            function parseDate(dateStr) {
                if (!dateStr || dateStr.trim() === '') return null;
                const parts = dateStr.trim().split('/');
                if (parts.length === 3) {
                    const day = parseInt(parts[0]);
                    const month = parseInt(parts[1]) - 1;
                    const year = parseInt(parts[2]);
                    return new Date(year, month, day);
                }
                return null;
            }

            cachedData.cds.sort((a, b) => {
                const dateA = parseDate(a.dateAcquisition);
                const dateB = parseDate(b.dateAcquisition);
                
                // Put items without date at the bottom
                if (!dateA && !dateB) return 0;
                if (!dateA) return 1;
                if (!dateB) return -1;
                
                if (sortAscendingDate) {
                    return dateA - dateB;
                } else {
                    return dateB - dateA;
                }
            });

            // Update button appearance
            const sortBtn = document.getElementById('sort-date-btn');
            if (sortAscendingDate) {
                sortBtn.classList.remove('descending');
                sortBtn.classList.add('ascending');
            } else {
                sortBtn.classList.add('descending');
                sortBtn.classList.remove('ascending');
            }

            // Re-render table (respect active search filter)
            applyAlbumSearch();
        }

        // Sort by price
        function sortByPrice() {
            if (!cachedData) return;

            // Toggle sort direction FIRST
            sortAscendingPrice = !sortAscendingPrice;

            cachedData.cds.sort((a, b) => {
                // Extract price number from strings like "15,50€" or "15.50€"
                const priceStrA = (a.price || '').toString().trim();
                const priceStrB = (b.price || '').toString().trim();
                const hasA = priceStrA && priceStrA !== '' && priceStrA !== '-';
                const hasB = priceStrB && priceStrB !== '' && priceStrB !== '-';
                
                // Put items without price at the bottom
                if (!hasA && !hasB) return 0;
                if (!hasA) return 1;
                if (!hasB) return -1;
                
                const priceA = parseFloat(priceStrA.replace(/[^0-9.,]/g, '').replace(',', '.')) || 0;
                const priceB = parseFloat(priceStrB.replace(/[^0-9.,]/g, '').replace(',', '.')) || 0;
                
                if (sortAscendingPrice) {
                    return priceA - priceB;
                } else {
                    return priceB - priceA;
                }
            });

            // Update button appearance
            const sortBtn = document.getElementById('sort-price-btn');
            if (sortAscendingPrice) {
                sortBtn.classList.remove('descending');
                sortBtn.classList.add('ascending');
            } else {
                sortBtn.classList.add('descending');
                sortBtn.classList.remove('ascending');
            }

            // Re-render table (respect active search filter)
            applyAlbumSearch();
        }

        // Sort by rating
        function sortByRating() {
            if (!cachedData) return;

            // Toggle sort direction FIRST
            sortAscendingRating = !sortAscendingRating;

            cachedData.cds.sort((a, b) => {
                const ratingA = parseFloat(a.rating) || 0;
                const ratingB = parseFloat(b.rating) || 0;
                
                // Put items without rating at the bottom
                if (ratingA === 0 && ratingB === 0) return 0;
                if (ratingA === 0) return 1;
                if (ratingB === 0) return -1;
                
                if (sortAscendingRating) {
                    return ratingA - ratingB;
                } else {
                    return ratingB - ratingA;
                }
            });

            // Update button appearance
            const sortBtn = document.getElementById('sort-rating-btn');
            if (sortAscendingRating) {
                sortBtn.classList.remove('descending');
                sortBtn.classList.add('ascending');
            } else {
                sortBtn.classList.add('descending');
                sortBtn.classList.remove('ascending');
            }

            // Re-render table (respect active search filter)
            applyAlbumSearch();
        }

        // Fetch and parse the JSON data (cache-busted)
        fetch('cdexcel.json?cb=' + Date.now())
            .then(response => response.json())
            .then(data => {
                cachedData = data;
                applyAlbumSearch();

                // Add click handlers to sort buttons
                document.getElementById('sort-artist-btn').addEventListener('click', sortByArtist);
                document.getElementById('sort-year-btn').addEventListener('click', sortByYear);
                document.getElementById('sort-date-btn').addEventListener('click', sortByDate);
                document.getElementById('sort-price-btn').addEventListener('click', sortByPrice);
                document.getElementById('sort-rating-btn').addEventListener('click', sortByRating);

                const searchToggle = document.getElementById('release-search-toggle');
                const searchPanel = document.getElementById('release-search-panel');
                const searchInput = document.getElementById('album-search-input');

                if (searchToggle && searchPanel && searchInput) {
                    searchToggle.addEventListener('click', function() {
                        const isOpen = searchPanel.classList.toggle('open');
                        searchPanel.setAttribute('aria-hidden', (!isOpen).toString());
                        searchToggle.classList.toggle('active', isOpen);

                        if (isOpen) {
                            searchInput.focus();
                        } else {
                            searchInput.value = '';
                            applyAlbumSearch();
                        }
                    });

                    searchInput.addEventListener('input', applyAlbumSearch);

                    searchInput.addEventListener('keydown', function(event) {
                        if (event.key === 'Escape') {
                            searchPanel.classList.remove('open');
                            searchPanel.setAttribute('aria-hidden', 'true');
                            searchToggle.classList.remove('active');
                            searchInput.value = '';
                            applyAlbumSearch();
                            searchToggle.focus();
                        }
                    });
                }
            })
            .catch(error => console.error('Error loading data:', error));
    </script>
</body>
</html>